
\chapter{Finite-tree algorithm}
\label{ch:finite-tree}
In this chapter we introduce basic definitions and concepts to another approach of $\JSR$ computation. It is called \emph{finite-tree algrithm} as its trying to decompose arbitrary products $P \in \mathcal{A}^k$ into sub-products that can be 1-bounded by an a priori chosen norm.  

\section{Notation and definitions}

\begin{definition}
    A \emph{tree} is a connected, acyclic graph \( T \) with a distinguished node \( t_0\) called the \emph{root}. The tree structure induces a natural hierarchy: for any node $t_i$, there exists a unique path from \( t_0 \) to \( t_i \). The tree can then be described in terms of the following concepts:
    \begin{itemize}
        \item \textbf{Parent}: For any node \( t \in T \), the node preceding \( t \) on the path from the root $t_0$ is called its \emph{parent}.
        \item \textbf{Children}: The nodes adjacent to a given node \( t \) that are further from the root $t_0$ are called its \emph{children}.
        \item \textbf{Leaf}: A node with no children is called a \emph{leaf}.
        \item \textbf{Internal vertex}: A node with at least one child is called an \emph{internal} or \emph{non-leaf} node.
    \end{itemize}
\end{definition}

 We define $T_{\mathcal{A}}$ as the tree consisting of all products in the set $\bigcup \limits_ {k \in \mathbb{N}_0}\mathcal{A}^k$ where every multi-index represents a node. For the empty index ($k = 0$)  we set $A_{[]} = I_d$ the identity matrix in $\R^{d\times d}$. An example can be seen in figure~\ref{fig:matrix-product-tree}.

\begin{figure}[ht]
\centering
\begin{forest}
    for tree={
        grow'=0,
        child anchor=west,
        parent anchor=east,
        l sep=20pt,
        s sep=20pt,
        edge={->, >=latex},
        anchor=base west,
        font=\small,
    }
    [{$A_{[]} = I_d$}
  [{$A_{[1]} = A_1$}
    [{$A_{[1,1]} = A_1 A_1$}
      [{$A_{[1,1,1]} = A_1 A_1 A_1 \quad \cdots$}]
      [{$A_{[1,1,2]} = A_2 A_1 A_1 \quad \cdots$}]
    ]
    [{$A_{[1,2]} = A_2 A_1$}
      [{$A_{[1,2,1]} = A_1 A_2 A_1 \quad \cdots$}]
      [{$A_{[1,2,2]} = A_2 A_2 A_1 \quad \cdots$}]
    ]
  ]
  [{$A_{[2]} = A_2$}
    [{$A_{[2,1]} = A_1 A_2$}
      [{$A_{[2,1,1]} = A_1 A_1 A_2 \quad \cdots$}]
      [{$A_{[2,1,2]} = A_2 A_1 A_2 \quad \cdots$}]
    ]
    [{$A_{[2,2]} = A_2 A_2$}
      [{$A_{[2,2,1]} = A_1 A_2 A_2 \quad \cdots$}]
      [{$A_{[2,2,2]} = A_2 A_2 A_2 \quad \cdots$}]
    ]
  ]
]
\end{forest}
\caption{An example of the tree $T_{\mathcal{A}}$ on $\bigcup_ {k \in \mathbb{N}_0}\mathcal{A}^k$ with $\mathcal{A} = \{A_1, A_2\}.$}
\label{fig:matrix-product-tree}
\end{figure}

The objective is now to find a sub-tree $T \subset T_{\mathcal{A}}$ for a chosen norm, with the condition of every leaf encoding a product that has a norm less then 1 and every node thats not a leaf having all possible children $A_1,\cdots,A_J$.
If such a tree has been found it easily allows for a decomposition of every possible product $P = A_{[i_1,\cdots,i_k]} \in \mathcal{A}^k$ into sub-products encoded by leafs and one possible rest term encoded by an internal-node. 
Leading to a proof of $\JSR(\tilde{\mathcal{A}}) = 1$.
\newline
Such sub-trees are in general not finite and therefore unusable for a computational tree-search algorithm.
In the paper \citep{mollerTreebasedApproachJoint2014}, the writers propose to use a different kind of encoding making use of so-called generators and set-valued nodes.

We fixate a set $\mathbf{G} = \{ g_1, \cdots, g_m \}$ with $g_i \in \bigcup_ {k \in \mathbb{N}}\mathcal{A}^k$ and $\rho(g_i)^{\frac{1}{k}} \le 1$.
All products from this set will be called \emph{generators}.
We also define $A_l := g_{-l}$ for $l \in \{-m, \dots, -1\}$.

\begin{definition}
    
    The set \( \mathcal{J}^k := \{-m, \dots, -1, 1, \dots, n\}^k \) denotes the collection of all multi-indeces of length \( k \) with entries in $\{-m, \dots, -1, 1, \dots, n\}$. 
    For an multi-index \( J = [j_1, \dots, j_k] \in \mathcal{J}^k \), the corresponding matrix product set is defined by:
    $$
    A_J := \{ A_{j_k}^{e_k} \cdots A_{j_1}^{e_1} \mid  e_i = 1  \text{ if } j_i > 0 \text{ or } \forall e_i \in \mathbb{N}_0 \text{ else}\} 
    $$
  
\end{definition}

Again this creates a tree structure in a similar way to positive multi-indeces, except now the nodes represent (possibly infinite) sets of products. 

\begin{definition}
    Let $J = [j_1, \cdots, j_k]$ be a multi-index. We define the multi-index extension with $J + j_{k+1} := [j_1, \cdots, j_k, j_{k+1}].$
\end{definition}

\begin{definition}
    Let $t \in T$ be a node with the multi-index $J$.
    A child node $\tilde{t}$ with the multi-index $J+j_{k+1}$ is called:
    \begin{itemize}
        \item \emph{positive} if $j_{k+1}$ is positive.
        \item \emph{negative} or \emph{generator} if $j_{k+1}$ is negative.
    \end{itemize}
\end{definition}

Now we want to find a subtree of a special form. 

\begin{definition}
    \label{def:tree}
    \begin{samepage}
    A so-called $(\mathcal{A},\mathbf{G})\text{-tree } T$ has the following structure: 
\begin{itemize}
    \item The root node contains the identity matrix: \( t_0 = \{I_d\} \).
    
    \item Each node \( t \in T \) is either:
    \begin{itemize}
        \item A leaf,
        \item A parent of exactly \( n \) positive children.
        \item A parent of only generators.
    \end{itemize}
\end{itemize}
\end{samepage}
\end{definition}


\begin{definition}
    A node in the tree is called \emph{covered} if it is a subset of one of its ancestors in the tree. Otherwise, it is called \emph{uncovered}. 
    The set of uncovered leaves is denoted as
\[
    \mathcal{L}(T) := \{ L \in t : t \in T \text{ is an uncovered leaf} \}.
\]
and called \emph{leafage} of the tree $T$.
\end{definition}

\begin{definition}
An $(\mathcal{A},\mathbf{G})\text{-tree}$ $T$ is called \emph{1-bounded} with respect to a matrix norm \( \| \cdot \| \) if
\[
    \sup_{L \in \mathcal{L}(T)} \| L \| \leq 1.
\]
If \( \sup_{L \in \mathcal{L}(T)} \| L \| < 1 \), then the tree is called \emph{strictly 1-bounded}.
\end{definition}

\section{Structure of the finite-tree algorithm}
The finite-tree algorithm tries to find a 1-bounded $(\mathcal{A},\mathbf{G})\text{-tree}$. We start with only the root node $t_0 = \{I\}$ and iteratively check in every step $ \sup \{\lVert P \rVert: P \in L\} \le 1$ for every leaf $L$ in the current tree. If for one particular leaf the bound doe not hold we add either all positive children or an arbitrary amount of generator children.

\begin{algorithm}[h]
    \caption{Finite-tree-algorithm}
    \label{alg:tree}
    \begin{algorithmic}
        \State \Input{$\mathcal{A} = \{A_1, \ldots, A_n\}$ and $\mathbf{G} = \{ g_1, \cdots, g_m \}$}
        \State \Output{A boolean value indicating whether the tree condition holds (True/False)}
        \State $Q \leftarrow \{[1], \cdots, [n]\}$
        \While{$Q \ne \emptyset$}
            \State $Q_{\text{new}} \leftarrow \emptyset$
            \For{$J \in Q$} 
                \If{$\sup \{ \lVert P \rVert : P \in A_J \} > 1$}
                    \State $\textbf{J} \leftarrow \textproc{selectChildren}(J, \mathcal{A}, \textbf{G})$ % See Remark~\ref{rem:moller}
                    \State $Q_{\text{new}} \xleftarrow{\cup} \{J + j: j \in \textbf{J}\}$
                \EndIf
            \EndFor
            \State $Q \leftarrow Q_{\text{new}}$
        \EndWhile \\
        \Return $\text{True}$
    \end{algorithmic}
\end{algorithm}

\begin{remark}\label{rem:moller}
The procedure \textproc{selectChildren} determines whether all positive children (from $1$ to $n$) or a subset of negative children (from $-1$ to $-m$) is chosen, according to the theory established in~\citep{mollerTreebasedApproachJoint2014}.
\end{remark}

\begin{lemma}
    \label{lem:poly_bound}
    For every $(\mathcal{A},\mathbf{G})\text{-tree } T$ there exists a strictly-positive, monotone polynomial $p$ such that for every node $t \in T$ and every product $P \in \mathcal{A}^k$ encoded by $t$, $\lVert P \rVert \le p(k)$ holds.
\end{lemma}
  
\begin{proof}
    Take an arbitrary node $t \in T$ with multi-index $J = [j_1, \cdots, j_l]$. 
    Now every $j_i$ encodes either a matrix from $\mathcal{A}$ or arbitrary powers of a generator from $\mathcal{G}$. 
    Since all those matrices have spectral radius less then or equal to 1, its Jordan normal forms grow utmost polynomially und thus, due to equality of norms in finite-dimensional vector spaces, there exists a strictly-positive, monotone polynomial $p_i$ with 
    $$ 
    \lVert A_{j_i}^{e} \rVert \le p_i(e) \quad \forall e \in \mathbb{N}_0.
    $$

    We define: 
    $$
    \begin{aligned}
    p_t & := p_{l} \cdots p_{1} \\
    p & := \sum \limits_{t \in T} p_t
    \end{aligned}
    $$
    The sum over all of $T$ is finite since $T$ has only finitely many nodes. 
    Take now an arbitrary product $P = A_{j_l}^{e_{l}}\cdots A_{j_1}^{e_1} \in \mathcal{A}^k$ that is encoded by $t$.
    
    Now we have: 
    $$
    \begin{aligned}
    \lVert P \rVert & = \lVert A_{j_l}^{e_{l}} \cdots A_{j_1}^{e_{1}} \rVert \\
    & \leq \lVert A_{j_l}^{e_{l}} \rVert \cdots \lVert A_{j_1}^{e_{1}} \rVert \\
    & \leq p_{l}(e_l) \cdots p_{1}(e_1) \\
    & \leq p_{l}( k) \cdots p_{1}( k) \\
    & = p_t( k) \leq p( k) \\
    \end{aligned}
    $$
    Since the node $t$ and the product $P$ were chosen arbitrary, this concludes the proof. 
\end{proof}

\begin{theorem}
\label{thm:tree_JSR_found}
    If a 1-bounded $(\mathcal{A},\mathbf{G})\text{-tree}$ was found for a given matrix set $\mathcal{A}$ and generator set $\mathbf{G}$ then $\JSR(\mathcal{A}) = 1$
\end{theorem}
~
\begin{proof}
    We take an arbitrary positive multi-index $I = [i_1, \cdots, i_k]$.
    Our found $(\mathcal{A},\mathbf{G})\text{-tree } T$ allows for a unique decomposition of this multi-index into $I_k, \cdots, I_1$ where 
    $$ 
    A_I = A_{I_k}A_{I_{k-1}}\cdots A_{I_1}.
    $$ 
    Each sub-multi-index $I_j \quad j = 1, \cdots,k-1$ encodes either a leaf of $T$ or is the empty set and $I_k$ encodes any node of $T$. Now due to Lemma~\ref{lem:poly_bound} there exists a polynomial $p$ such that
    \[ 
        \lVert A_{I}  \rVert =  \lVert A_{I_k}A_{I_{k-1}}\cdots A_{I_1}\rVert \le  \lVert A_{I_k} \rVert \cdot \lVert A_{I_{k-1}}\rVert \cdots \lVert A_{I_1} \rVert \le \lVert A_{I_k} \rVert\le p(k).
    \]
    The last equality holds since all $I_j \quad j = 1, \cdots,k-1$ are either the empty multi-index or leafs such that their products $A_{I_j}$ are bounded by 1. 
    Furthermore $A_{I_k}$ can be bounded by the polynomial $p$ and the length of the product, which is less then $k$. 
    Now we have
      $$\JSR(\mathcal{A}) = \lim_k \max_{P \in \mathcal{A}^k} \lVert P \rVert ^{\frac{1}{k}} \leq \lim_k p(k) ^{\frac{1}{k}}  = 1$$
    since the chosen multi-index was arbitrary.
\end{proof}

\begin{remark}
    The decomposition used in the proof of Theorem~\ref{thm:tree_JSR_found} exists and is unique due to the structure of an $(\mathcal{A},\mathbf{G})\text{-tree}$.
    \textcolor{red}{glueing tree on covered nodes creating an infinite tree that allows huffman encoding directly. Empty sets for every $I_i$ if product already lies on internal node before $I_k$}
    For more info see \citep{mollerTreebasedApproachJoint2014}.
\end{remark}

\section{Conditions of termination}

\begin{remark}
    In~\citep{mollerTreebasedApproachJoint2014}, the authors show that the use of generators is essential for ensuring termination in cases where the original invariant-polytope algorithm fails to terminate. But deciding when to use generators instead of all positive children is still part of active research and is handled via highly heuristical approaches. 
\end{remark}


