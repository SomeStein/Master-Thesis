
\chapter{Hybrid approach} 
\label{ch:hybrid}

In this chapter we want to explore some possible combinations of the before mentioned algorithm schemes and then present the main result of this work, the Tree-flavored-invariant-polytope-algorithm and its termination results. 

\begin{section}{Goal and options}
In its heart the invariant-polytope algorithm tries to find a norm thats specifically optimized on the given problem, whilst the finite-tree algorithm connects growth to decompositions of products. A clear combination scheme arises naturally, where we use the optimized polytope norm to estimate the products of the finite-tree. From there we can choose a specific order or level of concurrency.
\newline
The most modular approach would be to first run the invariant-polytope algorithm for a couple of runs and then use the calculated norm thats specially optimized for the finite-tree algorithm. But that seems to be wasteful since valuable matrix calculations from the finite-tree algorithm could have been used for an even more optimized norm and some polytopes might have already cleared insight for the decompositions that the finite-tree algorithm tries to find. So after a bit of rethinking we managed to come up with a more concurrent algorithm that builds up norms and decompositions in every step. 
\end{section}

\section{Structure of the hybrid algorithm}

We try to decompose arbitrary products $P$ from factors from $\mathcal{A}$, such that their polytope-norms are less then $p(k)$ where $k$ is the number of factrors from $P$ and $p$ is a monotone polynomial.
This removes the invariance property of the polytope to be build up, since the norms dont have to be less than 1 but it still proofes the JSR identity because we take the weighted norms in the length of the products in the three-member-inequality ~\ref{eq:three-member}.
\newline 
Starting the loop of the invariant-polytope algorithm with a cycle on top that is connected via the generators factors and also the first branches represented by images from the missing $J-1$ factors from $\mathcal{A}$. Instead of only adding images under vertices from $V$ and matrices from $\mathcal{A}$ directly, from now on we try to find an $(\mathcal{A},\mathbf{G})\text{-tree}$ which is one-bounded i.e its leafage-polytope-norm is less than 1, for every $v \in V$.
For that we generate $(\mathcal{A},\mathbf{G})\text{-tree}$ patterns in the beginning and just go through every remaining vertex and calculate the leafage-norms. From the structure of those trees we can assume that every matrix in $\mathcal{A}$ represents a node for the first branches.
For the branches that lead to a leafage-norm less than or equal 1 we are done, for the other branches we have the choice to go deeper or just add some points to $V$ that changes the leafage-norm of those branches to less than 1. Here we decided to add the points since going deeper just would mean to consider possibly the same products but the tree generation would be more complex with options for depth-first- or breadth-first-search and even using some s.m.p and generator trickery. [might change it in the future]
\newline
First points that come to mind are the leafage-points itself since this is what we have tested but generators could be involved meaning there are possibly infinitely many leafage-points. So the next best thing would be the roots of the branches which are guaranteed to be a single matrix from $\mathcal{A}$. This makes tree generation easy and adds points with likely more distance to the faces of the polytope and makes the norm stronger more quickly.
\newline
So in principle for every $v \in V_{\text{rem}}$ take a tree from the generating pool, check the leafage-norm for every root branch, if it is larger than 1 add the point from the root branch to $V_{\text{new}}$ and $V$. After one step change $V_{\text{rem}}$ to $V_{\text{new}}$ and $V_{\text{new}}$ to the empty set and repeat this as long as new vertices have been added. We use $V$ for the polytope-norms and since new points are only being added the norms decrease over time so all 1-bounded trees stay bounded.
\newline
After termination the set of trees generated promise a valid decomposition for every product from $\mathcal{A}$ into chunks of norm lesser 1 and one suffix thats of norm less than $p(k)$ for some monotone polynomial, which proofes the question if the chosen radius is maximal.

\vspace{1cm}

\begin{algorithm}
  \caption{Tree-flavored-invariant-polytope-algorithm}
  \label{alg:hybrid}
  \begin{algorithmic}
      \State $V := \{v_1, \cdots, v_M\}$
      \State $V_{\text{new}} \gets V$
      \While {$V_{\text{new}} \ne \emptyset$}
          \State $V_{\text{rem}} \gets V_{\text{new}}$
          \State $V_{\text{new}} \gets \emptyset$
          \For {$v \in V_{\text{rem}}$}
              \State $\text{Construct some } (\mathcal{A},\mathbf{G})\text{-tree } \mathbf{T}$
              \For {$L = L'A \in \mathcal{L}(T) \text{ with } A \in \mathcal{A}$}
                  \If {$\lVert Lv \rVert_{\text{co}_{\text{s}}(V)} \geq 1$}
                      \State $V \gets V \cup Av$
                      \State $V_{\text{new}} \gets V_{\text{new}} \cup Av$
                  \EndIf
              \EndFor
          \EndFor
      \EndWhile \\
      \Return \\
  \end{algorithmic}
\end{algorithm}

\vspace{1cm}

The following figure~\ref{fig:cyclic_tree_structure} shows an example of the generated tree structure as well as the tested $(\mathcal{A},\mathbf{G})\text{-trees}$ that have been used to bound the products. Here $\mathcal{A}$ consists of two matrices $A$ and $B$ and the chosen candidate is $ \Pi = ABA$. At the top you can see the cycle generated by the candidate and the starting vector $v_1$ as well as branches coming of that are the products that stay in contrast to the cycle. This is what i call the crown and it is generated for every matrix set at the beginning, so no testing has been made so far. All the nodes that are connected through a solid arrow have been added to the vertices $V$.

\begin{figure}[H]
\centering
\begin{tikzpicture}[
  %every node/.style={circle, draw, inner sep=2pt},
  edge from parent/.style={draw, -latex, dashed},
  level distance=10mm,
  sibling distance=23mm
  ]

% Define root nodes circle
\node (v1) at (-1.5, 2) {$v_1$};
\node (v2) at (1.5, 2) {$v_2$};
\node (v3) at (0, 0) {$v_3$};

% Add curved arrows between root nodes
\draw[->, thick, rounded corners, bend left=30] (v1) to node[midway, above] {$A$} (v2);
\draw[->, thick, rounded corners, bend left=30] (v2) to node[midway, above] {$B$} (v3);
\draw[->, thick, rounded corners, bend left=30] (v3) to node[midway, above] {$A$} (v1);

% m-1 products
\node (v4) at (-3.5,0) {$v_4$}
  child{node{$\{Av_4\}$}}
  child{node{$\{Bv_4\}$}};
\node (v5) at (4,-0.5) {$v_5$}
  child {node {$\{ Av_7\}$}}
  child {
    child { 
      child {node {$\{AG^nBv_5\}$}} 
      child {
        child {node {$\{ABG^nBv_5\}$}} 
        child {node {$\{BBG^nBv_5\}$}}
      }
    }
  };
\node (v6) at (0,-1.5) {$v_6$};
\node (v7) at (-1.7, -3.5) {$v_7$}
  child {node {$\{ Av_7\}$}}
  child {
    child { 
      child {node {$\{AG^nBv_7\}$}} 
      child {node {$\{BG^nBv_7\}$}}
    }
  };
\node (v8) at (1.7, -3.5) {}
  child {node {$\{ ABv_6\}$}}
  child {node {$\{ BBv_6\}$}};
  

% Add curved arrows between root nodes
\draw[->, thick, rounded corners] (v2) to node[midway, above] {$A$} (v5);
\draw[->, thick, rounded corners] (v1) to node[midway, above] {$B$} (v4);
\draw[->, thick, rounded corners] (v3) to node[midway, above] {$B$} (v6);
\draw[->, thick, rounded corners] (v6) to node[midway, above] {$A$} (v7);
\draw[->, dashed, -latex] (v6) to node[midway, above] {$B$} (v8);

\end{tikzpicture}
\caption{Cyclic tree structure generated by the algorithm. Vertices added to $V$ (solid arrows) and finite-trees for bounding products (dashed arrows).}
\label{fig:cyclic_tree_structure}
\end{figure}

Now the finite-tree theory comes in and every vertex gets tested by a $(\mathcal{A},\mathbf{G})\text{-tree}$ (dashed arrows). Take the vector $v_6$ for example it has been tested by an tree and the branch starting with the matrix $B$ was sufficient i.e. every leaf-node has a polytope-norm of less than 1 (at the time the polytope consists of the vertices $V = \{v_1, \cdots, v_6\}$). The branch starting with the matrix $A$ on the other hand didnt, so the vertex $v_7 = Av_6$ has been added to $V$ and the next tree was tested, which was fully sufficient (on every branch). Since the other branches also terminated earlier the algorithm stops, no more vertices are beeing added and the candidate $\Pi$ was proofen to be a s.m.p product. 

\section{Termination results}

\begin{theorem}{}\label{thm:hybrid-found}
If Algorithm~\ref{alg:hybrid} terminates then $JSR(\mathcal{A}) \leq 1$
\end{theorem}

\begin{proof}
Suppose the algorithm terminates and creates a set $V$ of vertices then for each $v \in V$ there exists an $(\mathcal{A},\mathbf{G})\text{-Tree } \mathbf{T}_{v}$ such that $\lVert Lv \rVert_{\mathbf{co}_s (V)} \leq 1 \quad \forall L \in \mathcal{L}(\mathbf{T}_{v}).$ \\
Taking arbitrary product $P \in \mathcal{A}^k$ and vector $v \in \mathbf{co}_s(V)$
we get:
$$\lVert Pv \rVert = \lVert P \sum \lambda_i v_i \rVert \leq \sum |\lambda_i| \lVert P v_i \rVert \quad \text{with} \quad \sum |\lambda_i| \leq 1$$
Now for every $i = 1 \cdots \lvert V \rvert$ there either exists a Tree-partition where $P = P'_i L_i $ with $L_i \in \mathcal{L}(T_{v_i})$ and $\lVert L_i v_i \rVert \leq 1$ or $P$ is element of a node of $T_{v_i}$ thats not a leave. If the partition exists the vector $L_iv_i$ lands within the symmetrized convex hull of $V$ and thus has a linear combination like before. \\
$$ \lVert P v_i \rVert = \lVert P'_i (L_i v_i) \rVert \leq \sum |\mu_j| \lVert P'_i v_j \rVert \quad \text{with} \quad \sum |\mu_j| \leq 1 $$
If there exists no such partition then the product is in some sense already small enough: A similar argument, like in \citep{mollerTreebasedApproachJoint2014} can be made, that theres only finitely many nodes in every tree and the spectral radius of every factor of such a matrix-product is less then 1. Norms of such products can be bounded by a monotone increasing polynomial $p(k)$ in the amount of factors $k$. \\
Since every product can be reduced to a product that has less factors (trees have to have at least $\mathcal{A}$ as branches) until it lies within an according tree we eventually get:
$$ \lVert Pv \rVert \leq \sum \limits_{i} |\lambda_i| \lVert P v_i \rVert \leq \sum\limits_{i_1}\sum\limits_{i_2}|\lambda_{i_1}||\lambda_{i_2|} \lVert P'_{i_1} v_{i_2} \rVert \leq \cdots $$
$$  \leq \sum \limits_{i_1,\cdots,i_k \in \Sigma} |\lambda_{i_1}| \cdot...\cdot |\lambda_{i_k}| \lVert P'_{i_1,\cdots,i_k}v_{i_k} \rVert \leq \sum \limits_{i_1,\cdots,i_k \in \Sigma} |\lambda_{i_1}|\cdot...\cdot|\lambda_{i_k}| \cdot p(k) \leq p(k)$$

the last inequality holds since the factors $\lambda_{\alpha}$ come from the linear combination of the polytopes vertices and the norm is less than 1 so the factors fullfil $\sum |\lambda_{\alpha}| \leq 1$. This implies $\lVert P \rVert \leq p(k)$ thus, since $P$ was chosen arbitrary:

$$JSR(\mathcal{A}) = \lim_k \max_{P \in \mathcal{A}^k} \lVert P \rVert ^{\frac{1}{k}} \leq \lim_k p(k) ^{\frac{1}{k}}  = 1$$

just like with the finite-tree algorithm.
\end{proof}

The idea for the polynomial is that by knowing the spectral radius of every matrix and generator to be less than 1 the jordan-blocks of matrices from one node are predictable in their growth under exponantiation. The growth is less than a monotone polynomial in the order of the size of the jordan-block. Now we have such a polynomial for every node and there are only finitely many nodes so we take the maximum of every monome factor and create a polynomial that bounds every nodes products.\\
This only works since the number of nodes is finite. If we would apply the same strategy on the infinite tree the absolute values of the factors for the polynomial would not be bounded. \\ \\

\begin{corollary}
  If the chosen trees are always $T_v = \mathcal{A}$ then we would have exactly the invariant-polytope algorithm \ref{alg:exact}. Which makes the new approach a real generalization. 
\end{corollary}

\begin{corollary}
  If the chosen trees do not make use of generators, then the polynomial bounding would collapse to just a constant $ K = \max\limits_{v \in V}\max\limits_{P \in T_{v}}: \lVert P \rVert_{co_{s}(V)}$ that is the maximal polytope-norm over all nodes and all used $(\mathcal{A},\mathbf{G})\text{-trees}$. This constant would not depend on the sizes of the products anymore.
\end{corollary}

\section{Efficiency}

\begin{theorem}
  The Tree-flavored-invariant-polytope algorithm has a bigger solution space than the invariant-polytope algorithm.
\end{theorem}

\begin{proof}
  [empty]
\end{proof}

\begin{theorem}
  The Tree-flavored-invariant-polytope algorithm is numerically faster than the finite-tree algorithm starting with an ill-conditioned norm.
\end{theorem}

It is hard to proof this but in the next Chapter \ref{ch:numerics} i will present some numerical results that support the claim.

\subsection*{Remarks}
\subsubsection*{Used trees}
It was proofen in \citep{mollerTreebasedApproachJoint2014} that in order to have a bigger solution space then algorithm \ref{alg:exact} the use of generators is mandatory. 
The choice of the testing-trees is not trivial and subject to active research. 
\subsubsection*{Stopping criterions}
Some of the stopping criterions of the invariant-polytope algorithm can still be used as the structure is very similar. 
Just some remarks...
\subsubsection*{Rebalancing and added starting vertices}
Rebalancing allows for multiple s.m.p's in the invariant-polytope algorithm so it has a bigger solution space but it is still comparable to the hybrid approach due to ...
\subsubsection*{Polytope invariance}
Since the norms of matrices in $\mathcal{A}$ are allowed to be bigger than 1 just less than $p(1)$ it is possible the polytope is not invariant. Although this is not the main goal, as we are trying to compute $JSR(\mathcal{A})$, but if one is interested in finding an invariant polytope anyway, one has to ...

